<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn, uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );"><title>xTaskGenericNotifyWait in esp_idf_sys - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-f40c346f39d9abc1.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="esp_idf_sys" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0-nightly (46514218f 2023-06-20)" data-search-js="search-95c92dd01058facf.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-190c35055d2a8300.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../esp_idf_sys/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../esp_idf_sys/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><div class="sidebar-elems"><h2><a href="index.html">In esp_idf_sys</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Function <a href="index.html">esp_idf_sys</a>::<wbr><a class="fn" href="#">xTaskGenericNotifyWait</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/esp_idf_sys/home/runner/work/esp-idf-hal/esp-idf-hal/target/riscv32imc-esp-espidf/debug/build/esp-idf-sys-bb8d988eb52dbf09/out/bindings.rs.html#16593-16599">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn xTaskGenericNotifyWait(
    uxIndexToWaitOn: <a class="type" href="type.UBaseType_t.html" title="type esp_idf_sys::UBaseType_t">UBaseType_t</a>,
    ulBitsToClearOnEntry: u32,
    ulBitsToClearOnExit: u32,
    pulNotificationValue: *mut u32,
    xTicksToWait: <a class="type" href="type.TickType_t.html" title="type esp_idf_sys::TickType_t">TickType_t</a>
) -&gt; <a class="type" href="type.BaseType_t.html" title="type esp_idf_sys::BaseType_t">BaseType_t</a></code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>@cond !DOC_EXCLUDE_HEADER_SECTION
task. h
@code{c}
BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn, uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );</p>
<p>BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );
@endcode
@endcond</p>
<p>Waits for a direct to task notification to be pending at a given index within
an array of direct to task notifications.</p>
<p>See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.</p>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
function to be available.</p>
<p>Each task has a private array of “notification values” (or ‘notifications’),
each of which is a 32-bit unsigned integer (uint32_t).  The constant
configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the
array, and (for backward compatibility) defaults to 1 if left undefined.
Prior to FreeRTOS V10.4.0 there was only one notification value per task.</p>
<p>Events can be sent to a task using an intermediary object.  Examples of such
objects are queues, semaphores, mutexes and event groups.  Task notifications
are a method of sending an event directly to a task without the need for such
an intermediary object.</p>
<p>A notification sent to a task can optionally perform an action, such as
update, overwrite or increment one of the task’s notification values.  In
that way task notifications can be used to send data to a task, or be used as
light weight and fast binary or counting semaphores.</p>
<p>A notification sent to a task will remain pending until it is cleared by the
task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their
un-indexed equivalents).  If the task was already in the Blocked state to
wait for a notification when the notification arrives then the task will
automatically be removed from the Blocked state (unblocked) and the
notification cleared.</p>
<p>A task can use xTaskNotifyWaitIndexed() to [optionally] block to wait for a
notification to be pending, or ulTaskNotifyTakeIndexed() to [optionally] block
to wait for a notification value to have a non-zero value.  The task does
not consume any CPU time while it is in the Blocked state.</p>
<p><strong>NOTE</strong> Each notification within the array operates independently - a task
can only block on one notification within the array at a time and will not be
unblocked by a notification sent to any other array index.</p>
<p>Backward compatibility information:
Prior to FreeRTOS V10.4.0 each task had a single “notification value”, and
all task notification API functions operated on that value. Replacing the
single notification value with an array of notification values necessitated a
new set of API functions that could address specific notifications within the
array.  xTaskNotifyWait() is the original API function, and remains backward
compatible by always operating on the notification value at index 0 in the
array. Calling xTaskNotifyWait() is equivalent to calling
xTaskNotifyWaitIndexed() with the uxIndexToWaitOn parameter set to 0.</p>
<p>@param uxIndexToWaitOn The index within the calling task’s array of
notification values on which the calling task will wait for a notification to
be received.  uxIndexToWaitOn must be less than
configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyWait() does
not have this parameter and always waits for notifications on index 0.</p>
<p>@param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value
will be cleared in the calling task’s notification value before the task is
marked as waiting for a new notification (provided a notification is not
already pending). Optionally blocks if no notifications are pending. Setting
ulBitsToClearOnEntry to ULONG_MAX (if limits.h is included) or 0xffffffffUL
(if limits.h is not included) will have the effect of resetting the task’s
notification value to 0. Setting ulBitsToClearOnEntry to 0 will leave the
task’s notification value unchanged.</p>
<p>@param ulBitsToClearOnExit If a notification is pending or received before
the calling task exits the xTaskNotifyWait() function then the task’s
notification value (see the xTaskNotify() API function) is passed out using
the pulNotificationValue parameter.  Then any bits that are set in
ulBitsToClearOnExit will be cleared in the task’s notification value (note
*pulNotificationValue is set before any bits are cleared).  Setting
ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL
(if limits.h is not included) will have the effect of resetting the task’s
notification value to 0 before the function exits.  Setting
ulBitsToClearOnExit to 0 will leave the task’s notification value unchanged
when the function exits (in which case the value passed out in
pulNotificationValue will match the task’s notification value).</p>
<p>@param pulNotificationValue Used to pass the task’s notification value out
of the function.  Note the value passed out will not be effected by the
clearing of any bits caused by ulBitsToClearOnExit being non-zero.</p>
<p>@param xTicksToWait The maximum amount of time that the task should wait in
the Blocked state for a notification to be received, should a notification
not already be pending when xTaskNotifyWait() was called.  The task
will not consume any processing time while it is in the Blocked state.  This
is specified in kernel ticks, the macro pdMS_TO_TICKS( value_in_ms ) can be
used to convert a time specified in milliseconds to a time specified in
ticks.</p>
<p>@return If a notification was received (including notifications that were
already pending when xTaskNotifyWait was called) then pdPASS is
returned.  Otherwise pdFAIL is returned.</p>
<p>@cond !DOC_SINGLE_GROUP
\defgroup xTaskNotifyWaitIndexed xTaskNotifyWaitIndexed
@endcond
\ingroup TaskNotifications</p>
</div></details></section></div></main></body></html>
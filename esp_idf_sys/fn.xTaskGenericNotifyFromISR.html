<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="@cond !DOC_EXCLUDE_HEADER_SECTION task. h @code{c} BaseType_t xTaskNotifyIndexedFromISR( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken ); BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken ); @endcode @endcond"><title>xTaskGenericNotifyFromISR in esp_idf_sys - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-f40c346f39d9abc1.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="esp_idf_sys" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0-nightly (46514218f 2023-06-20)" data-search-js="search-95c92dd01058facf.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-190c35055d2a8300.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../esp_idf_sys/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../esp_idf_sys/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><div class="sidebar-elems"><h2><a href="index.html">In esp_idf_sys</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Function <a href="index.html">esp_idf_sys</a>::<wbr><a class="fn" href="#">xTaskGenericNotifyFromISR</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/esp_idf_sys/home/runner/work/esp-idf-hal/esp-idf-hal/target/riscv32imc-esp-espidf/debug/build/esp-idf-sys-bb8d988eb52dbf09/out/bindings.rs.html#16582-16589">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub unsafe extern &quot;C&quot; fn xTaskGenericNotifyFromISR(
    xTaskToNotify: <a class="type" href="type.TaskHandle_t.html" title="type esp_idf_sys::TaskHandle_t">TaskHandle_t</a>,
    uxIndexToNotify: <a class="type" href="type.UBaseType_t.html" title="type esp_idf_sys::UBaseType_t">UBaseType_t</a>,
    ulValue: u32,
    eAction: <a class="type" href="type.eNotifyAction.html" title="type esp_idf_sys::eNotifyAction">eNotifyAction</a>,
    pulPreviousNotificationValue: *mut u32,
    pxHigherPriorityTaskWoken: *mut <a class="type" href="type.BaseType_t.html" title="type esp_idf_sys::BaseType_t">BaseType_t</a>
) -&gt; <a class="type" href="type.BaseType_t.html" title="type esp_idf_sys::BaseType_t">BaseType_t</a></code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>@cond !DOC_EXCLUDE_HEADER_SECTION
task. h
@code{c}
BaseType_t xTaskNotifyIndexedFromISR( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );
BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );
@endcode
@endcond</p>
<p>See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.</p>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these
functions to be available.</p>
<p>A version of xTaskNotifyIndexed() that can be used from an interrupt service
routine (ISR).</p>
<p>Each task has a private array of “notification values” (or ‘notifications’),
each of which is a 32-bit unsigned integer (uint32_t).  The constant
configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the
array, and (for backward compatibility) defaults to 1 if left undefined.
Prior to FreeRTOS V10.4.0 there was only one notification value per task.</p>
<p>Events can be sent to a task using an intermediary object.  Examples of such
objects are queues, semaphores, mutexes and event groups.  Task notifications
are a method of sending an event directly to a task without the need for such
an intermediary object.</p>
<p>A notification sent to a task can optionally perform an action, such as
update, overwrite or increment one of the task’s notification values.  In
that way task notifications can be used to send data to a task, or be used as
light weight and fast binary or counting semaphores.</p>
<p>A task can use xTaskNotifyWaitIndexed() to [optionally] block to wait for a
notification to be pending, or ulTaskNotifyTakeIndexed() to [optionally] block
to wait for a notification value to have a non-zero value.  The task does
not consume any CPU time while it is in the Blocked state.</p>
<p>A notification sent to a task will remain pending until it is cleared by the
task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their
un-indexed equivalents).  If the task was already in the Blocked state to
wait for a notification when the notification arrives then the task will
automatically be removed from the Blocked state (unblocked) and the
notification cleared.</p>
<p><strong>NOTE</strong> Each notification within the array operates independently - a task
can only block on one notification within the array at a time and will not be
unblocked by a notification sent to any other array index.</p>
<p>Backward compatibility information:
Prior to FreeRTOS V10.4.0 each task had a single “notification value”, and
all task notification API functions operated on that value. Replacing the
single notification value with an array of notification values necessitated a
new set of API functions that could address specific notifications within the
array.  xTaskNotifyFromISR() is the original API function, and remains
backward compatible by always operating on the notification value at index 0
within the array. Calling xTaskNotifyFromISR() is equivalent to calling
xTaskNotifyIndexedFromISR() with the uxIndexToNotify parameter set to 0.</p>
<p>@param uxIndexToNotify The index within the target task’s array of
notification values to which the notification is to be sent.  uxIndexToNotify
must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyFromISR()
does not have this parameter and always sends notifications to index 0.</p>
<p>@param xTaskToNotify The handle of the task being notified.  The handle to a
task can be returned from the xTaskCreate() API function used to create the
task, and the handle of the currently running task can be obtained by calling
xTaskGetCurrentTaskHandle().</p>
<p>@param ulValue Data that can be sent with the notification.  How the data is
used depends on the value of the eAction parameter.</p>
<p>@param eAction Specifies how the notification updates the task’s notification
value, if at all.  Valid values for eAction are as follows:</p>
<p>eSetBits -
The task’s notification value is bitwise ORed with ulValue.  xTaskNotify()
always returns pdPASS in this case.</p>
<p>eIncrement -
The task’s notification value is incremented.  ulValue is not used and
xTaskNotify() always returns pdPASS in this case.</p>
<p>eSetValueWithOverwrite -
The task’s notification value is set to the value of ulValue, even if the
task being notified had not yet processed the previous notification (the
task already had a notification pending).  xTaskNotify() always returns
pdPASS in this case.</p>
<p>eSetValueWithoutOverwrite -
If the task being notified did not already have a notification pending then
the task’s notification value is set to ulValue and xTaskNotify() will
return pdPASS.  If the task being notified already had a notification
pending then no action is performed and pdFAIL is returned.</p>
<p>eNoAction -
The task receives a notification without its notification value being
updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
this case.</p>
<p>@param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set
*pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
task to which the notification was sent to leave the Blocked state, and the
unblocked task has a priority higher than the currently running task.  If
xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should
be requested before the interrupt is exited.  How a context switch is
requested from an ISR is dependent on the port - see the documentation page
for the port in use.</p>
<p>@param pulPreviousNotificationValue -
Can be used to pass out the subject task’s notification value before any
bits are modified by the notify function.</p>
<p>@return Dependent on the value of eAction.  See the description of the
eAction parameter.</p>
<p>@cond !DOC_SINGLE_GROUP
\defgroup xTaskNotifyIndexedFromISR xTaskNotifyIndexedFromISR
@endcond
\ingroup TaskNotifications</p>
</div></details></section></div></main></body></html>